{
    parserClass="com.lark.syntax.parser.LarkParser"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Lark"
    psiImplClassSuffix="Impl"
    psiPackage="com.lark.syntax.psi"
    psiImplPackage="com.lark.syntax.psi.impl"

    elementTypeHolderClass="com.lark.syntax.psi.LarkTypes"
    elementTypeClass="com.lark.syntax.psi.LarkElementType"
    tokenTypeClass="com.lark.syntax.psi.LarkTokenType"
}

larkFile ::= (item_ | line_end_)*

private item_ ::= rule_def
                | token_def
                | ignore_statement
                | import_statement
                | declare_statement
                {recoverWhile=item_recovery_}

private item_recovery_ ::= line_end_ !(RULE|TOKEN|IGNORE|IMPORT|DECLARE)

private line_end_ ::= COMMENT? NEWLINE

rule_def ::= RULE priority? COLON expansions line_end_ {pin=1}
token_def ::= TOKEN priority? COLON expansions line_end_ {pin=1}

priority ::= DOT [NUMBER]


ignore_statement ::= IGNORE expansions line_end_ {pin=1}
import_statement ::= IMPORT import_args [ARROW RULE] line_end_ {pin=1}
declare_statement ::= DECLARE TOKEN+ line_end_ {pin=1}

import_args ::= DOT? RULE (DOT (RULE|TOKEN))*

expansions ::= alias ((COMMENT? NEWLINE)? VBAR alias)*

alias ::= expansion [ARROW [RULE]]

expansion ::= expr*

expr ::= atom_ [QUANT | TILDE NUMBER [DOT_DOT NUMBER]]

private atom_ ::= atom_par|atom_opt|atom_ran|atom_ref|atom_lit

atom_par ::= OP expansions CP {pin=1}
atom_opt ::= OB expansions CB {pin=1}
atom_ran ::= STRING DOT_DOT STRING  {pin=2}
atom_ref ::= RULE | TOKEN
atom_lit ::= (REGEXP | STRING)

