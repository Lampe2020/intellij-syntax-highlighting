{
    parserClass="com.lark.syntax.parser.LarkParser"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Lark"
    psiImplClassSuffix="Impl"
    psiPackage="com.lark.syntax.psi"
    psiImplPackage="com.lark.syntax.psi.impl"
    psiImplUtilClass="com.lark.syntax.psi.impl.LarkPsiImplUtil"

    elementTypeHolderClass="com.lark.syntax.psi.LarkTypes"
    elementTypeClass="com.lark.syntax.psi.LarkElementType"
    tokenTypeClass="com.lark.syntax.psi.LarkTokenType"
}

larkFile ::= item_*

private item_ ::= rule_def
                | token_def
                | ignore_statement
                | import_statement
                | declare_statement
                | line_end_
                {recoverWhile=item_recovery_}

private item_recovery_ ::= !(RULE|TOKEN|IGNORE|IMPORT|DECLARE|COMMENT|line_end_)

private line_end_ ::= COMMENT? NEWLINE

rule_def ::= RULE priority? COLON expansions line_end_ {pin=1 methods=[getDefName]}
token_def ::= TOKEN priority? COLON expansions line_end_ {pin=1 methods=[getDefName]}

priority ::= DOT NUMBER {pin=1}


ignore_statement ::= IGNORE expansions line_end_ {pin=1}
import_statement ::= IMPORT import_args [ARROW (RULE|TOKEN)] line_end_ {pin=1 methods=[getDefName]}
declare_statement ::= DECLARE TOKEN+ line_end_ {pin=1 methods=[getDefNames]}

import_args ::= DOT? (RULE DOT)* (RULE|TOKEN) {methods=[getDefName]}

expansions ::= alias (line_end_? VBAR alias)*

alias ::= expansion [alias_]

private alias_ ::= ARROW RULE {pin=1}

expansion ::= expr*

expr ::= atom_ [QUANT | range]

private range ::= TILDE NUMBER DOT_DOT NUMBER {pin=1}

private atom_ ::= atom_par|atom_opt|atom_ran|atom_ref|atom_lit

atom_par ::= OP expansions CP {pin=1}
atom_opt ::= OB expansions CB {pin=1}
atom_ran ::= STRING DOT_DOT STRING  {pin=2}
atom_ref ::= RULE | TOKEN
atom_lit ::= (REGEXP | STRING)

